<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>cai_lw&#39;s competitive programming library: cplib::HashTable&lt; T, Hash, Eq &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript">var page_layout=1;</script>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="side-nav" class="ui-resizable side-nav-resizable"><!-- do not remove this div, it is closed by doxygen! -->
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">cai_lw&#39;s competitive programming library
   </div>
  </td>
 </tr>
   <tr><td colspan="2">        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td></tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classcplib_1_1HashTable.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classcplib_1_1HashTable-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">cplib::HashTable&lt; T, Hash, Eq &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__hash.html">Hash functions and containers</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Linear probing hash table with <code>std</code> non-compliant interface.  
 <a href="classcplib_1_1HashTable.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="table_8hpp_source.html">table.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a1cb52ff86014748d32ac5b38d5b64355"><td class="memItemLeft" align="right" valign="top"><a id="a1cb52ff86014748d32ac5b38d5b64355" name="a1cb52ff86014748d32ac5b38d5b64355"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b> = std::size_t</td></tr>
<tr class="separator:a1cb52ff86014748d32ac5b38d5b64355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b88fd53d7ac6bb31894e09740bb4b9b"><td class="memItemLeft" align="right" valign="top"><a id="a0b88fd53d7ac6bb31894e09740bb4b9b" name="a0b88fd53d7ac6bb31894e09740bb4b9b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b> = T</td></tr>
<tr class="separator:a0b88fd53d7ac6bb31894e09740bb4b9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeff65c7c4c56f50c25520511a47f1379"><td class="memItemLeft" align="right" valign="top"><a id="aeff65c7c4c56f50c25520511a47f1379" name="aeff65c7c4c56f50c25520511a47f1379"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>cell_iterator</b> = typename std::vector&lt; impl::HashCell&lt; T &gt; &gt;::iterator</td></tr>
<tr class="separator:aeff65c7c4c56f50c25520511a47f1379"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa49fc81fe14461cb7c7f714be5e6b7ba"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcplib_1_1HashTable.html#aa49fc81fe14461cb7c7f714be5e6b7ba">HashTable</a> ()</td></tr>
<tr class="memdesc:aa49fc81fe14461cb7c7f714be5e6b7ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an empty hash table.  <br /></td></tr>
<tr class="separator:aa49fc81fe14461cb7c7f714be5e6b7ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf5836817332c7abf749888d6d35c606"><td class="memTemplParams" colspan="2">template&lt;typename InputIt &gt; </td></tr>
<tr class="memitem:aaf5836817332c7abf749888d6d35c606"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcplib_1_1HashTable.html#aaf5836817332c7abf749888d6d35c606">HashTable</a> (InputIt first, InputIt last)</td></tr>
<tr class="memdesc:aaf5836817332c7abf749888d6d35c606"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a hash table containing elements from a pair of iterators.  <br /></td></tr>
<tr class="separator:aaf5836817332c7abf749888d6d35c606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aced5fc799cb947d4dc92749355e38adc"><td class="memItemLeft" align="right" valign="top"><a id="aced5fc799cb947d4dc92749355e38adc" name="aced5fc799cb947d4dc92749355e38adc"></a>
size_type&#160;</td><td class="memItemRight" valign="bottom"><b>size</b> () const</td></tr>
<tr class="memdesc:aced5fc799cb947d4dc92749355e38adc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in the hash table. <br /></td></tr>
<tr class="separator:aced5fc799cb947d4dc92749355e38adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9304b124d70f7c4f17ee0059b1f7bb54"><td class="memItemLeft" align="right" valign="top"><a id="a9304b124d70f7c4f17ee0059b1f7bb54" name="a9304b124d70f7c4f17ee0059b1f7bb54"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>empty</b> () const</td></tr>
<tr class="memdesc:a9304b124d70f7c4f17ee0059b1f7bb54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the hash table contains no element. <br /></td></tr>
<tr class="separator:a9304b124d70f7c4f17ee0059b1f7bb54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50b9e165681943484e529a6280f96694"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcplib_1_1HashTable.html#a50b9e165681943484e529a6280f96694">capacity</a> () const</td></tr>
<tr class="memdesc:a50b9e165681943484e529a6280f96694"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the underlying array of cells.  <br /></td></tr>
<tr class="separator:a50b9e165681943484e529a6280f96694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e097fb9e0c700b815f0a76922dd91f0"><td class="memItemLeft" align="right" valign="top"><a id="a4e097fb9e0c700b815f0a76922dd91f0" name="a4e097fb9e0c700b815f0a76922dd91f0"></a>
cell_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>cell_begin</b> ()</td></tr>
<tr class="memdesc:a4e097fb9e0c700b815f0a76922dd91f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointer to the beginning of the cell array. <br /></td></tr>
<tr class="separator:a4e097fb9e0c700b815f0a76922dd91f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad097cc53e956f4352b33f0d2adaab71f"><td class="memItemLeft" align="right" valign="top">cell_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcplib_1_1HashTable.html#ad097cc53e956f4352b33f0d2adaab71f">cell_end</a> ()</td></tr>
<tr class="memdesc:ad097cc53e956f4352b33f0d2adaab71f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointer to the end of the cell array.  <br /></td></tr>
<tr class="separator:ad097cc53e956f4352b33f0d2adaab71f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8527692f870c42154f93387ad45bd6d6"><td class="memTemplParams" colspan="2">template&lt;bool Revive = false&gt; </td></tr>
<tr class="memitem:a8527692f870c42154f93387ad45bd6d6"><td class="memTemplItemLeft" align="right" valign="top">cell_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcplib_1_1HashTable.html#a8527692f870c42154f93387ad45bd6d6">find_cell</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a8527692f870c42154f93387ad45bd6d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find an element that compares equal to the given value, or an empty cell if not found.  <br /></td></tr>
<tr class="separator:a8527692f870c42154f93387ad45bd6d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88fb229fb3a79a8bccdfdc4319114762"><td class="memItemLeft" align="right" valign="top"><a id="a88fb229fb3a79a8bccdfdc4319114762" name="a88fb229fb3a79a8bccdfdc4319114762"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>contains</b> (const T &amp;x) const</td></tr>
<tr class="memdesc:a88fb229fb3a79a8bccdfdc4319114762"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether an element that compares equal to the given value is found in the hash table. <br /></td></tr>
<tr class="separator:a88fb229fb3a79a8bccdfdc4319114762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c3e3d62552ddcde47bde68a9b4641e5"><td class="memTemplParams" colspan="2">template&lt;bool Replace = false&gt; </td></tr>
<tr class="memitem:a7c3e3d62552ddcde47bde68a9b4641e5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcplib_1_1HashTable.html#a7c3e3d62552ddcde47bde68a9b4641e5">insert</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a7c3e3d62552ddcde47bde68a9b4641e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an element if there is no element already present that compares equal to it.  <br /></td></tr>
<tr class="separator:a7c3e3d62552ddcde47bde68a9b4641e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04c7ad4184bc1117f6f616133aa6dce9"><td class="memTemplParams" colspan="2">template&lt;bool Replace = false&gt; </td></tr>
<tr class="memitem:a04c7ad4184bc1117f6f616133aa6dce9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcplib_1_1HashTable.html#a04c7ad4184bc1117f6f616133aa6dce9">insert</a> (T &amp;&amp;x)</td></tr>
<tr class="memdesc:a04c7ad4184bc1117f6f616133aa6dce9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an element if there is no element already present that compares equal to it.    <br /></td></tr>
<tr class="separator:a04c7ad4184bc1117f6f616133aa6dce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ff2aa0b711a5f890067fea32f62950d"><td class="memItemLeft" align="right" valign="top"><a id="a7ff2aa0b711a5f890067fea32f62950d" name="a7ff2aa0b711a5f890067fea32f62950d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>erase</b> (const T &amp;x)</td></tr>
<tr class="memdesc:a7ff2aa0b711a5f890067fea32f62950d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the element that compares equal to the given value if it is present. <br /></td></tr>
<tr class="separator:a7ff2aa0b711a5f890067fea32f62950d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4915ac2418f2853af89b09e44a9f194"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcplib_1_1HashTable.html#ac4915ac2418f2853af89b09e44a9f194">rehash</a> (size_type new_cap)</td></tr>
<tr class="memdesc:ac4915ac2418f2853af89b09e44a9f194"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate the given capacity, and rehash all elements.  <br /></td></tr>
<tr class="separator:ac4915ac2418f2853af89b09e44a9f194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6781bf89748842f602588c1aac677b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcplib_1_1HashTable.html#ac6781bf89748842f602588c1aac677b4">reserve</a> (size_type new_size)</td></tr>
<tr class="memdesc:ac6781bf89748842f602588c1aac677b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserve capacity and temporary disable shrinking.  <br /></td></tr>
<tr class="separator:ac6781bf89748842f602588c1aac677b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename T, typename Hash = WyHash&lt;T&gt;, typename Eq = std::equal_to&lt;T&gt;&gt;<br />
class cplib::HashTable&lt; T, Hash, Eq &gt;</div><p>Linear probing hash table with <code>std</code> non-compliant interface. </p>
<p>This hash table aims to be fast for typical competitive programming use cases. Insertion, lookup and deletion takes expected \(O(1)\) time.</p>
<p>Only the lower bits of the hash value are used, so the hash function must be reasonably chaotic, and for integer types <code>std::hash</code> is not acceptable. By default it uses <a class="el" href="structcplib_1_1WyHash.html" title="Hash function class like std::hash but uses wyhash.">WyHash</a>.</p>
<p>Due to lazy deletion, there are two load factors, the larger "non-empty" load factor which counts cells marked for deletion, and the smaller "occupied" load factor which doesn't. The rehashing policy is that both load factors are always within \([\frac{1}{8},\frac{1}{2}]\), unless the capacity is manually set (see <a class="el" href="classcplib_1_1HashTable.html#ac6781bf89748842f602588c1aac677b4" title="Reserve capacity and temporary disable shrinking.">HashTable::reserve</a>). The lower bound is required for \(O(N)\) traversal. In addition, the capacity is always a power of two, and is at least 4.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of elements. </td></tr>
    <tr><td class="paramname">Hash</td><td>Hash function object. </td></tr>
    <tr><td class="paramname">Eq</td><td>Equality comparison function object. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aa49fc81fe14461cb7c7f714be5e6b7ba" name="aa49fc81fe14461cb7c7f714be5e6b7ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa49fc81fe14461cb7c7f714be5e6b7ba">&#9670;&#160;</a></span>HashTable() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Hash  = WyHash&lt;T&gt;, typename Eq  = std::equal_to&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcplib_1_1HashTable.html">cplib::HashTable</a>&lt; T, Hash, Eq &gt;::HashTable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an empty hash table. </p>
<p>Note that this constructor allocates cells for a capacity of 4 even for an empty hash table. </p>

</div>
</div>
<a id="aaf5836817332c7abf749888d6d35c606" name="aaf5836817332c7abf749888d6d35c606"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf5836817332c7abf749888d6d35c606">&#9670;&#160;</a></span>HashTable() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Hash  = WyHash&lt;T&gt;, typename Eq  = std::equal_to&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename InputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcplib_1_1HashTable.html">cplib::HashTable</a>&lt; T, Hash, Eq &gt;::HashTable </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a hash table containing elements from a pair of iterators. </p>
<p>If the iterators are random access iterators, the number of elements is known, so sufficient space will be allocated in advance, so that no rehashing happens during construction. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a50b9e165681943484e529a6280f96694" name="a50b9e165681943484e529a6280f96694"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50b9e165681943484e529a6280f96694">&#9670;&#160;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Hash  = WyHash&lt;T&gt;, typename Eq  = std::equal_to&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classcplib_1_1HashTable.html">cplib::HashTable</a>&lt; T, Hash, Eq &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size of the underlying array of cells. </p>
<p>This is always a power of two. </p>

</div>
</div>
<a id="ad097cc53e956f4352b33f0d2adaab71f" name="ad097cc53e956f4352b33f0d2adaab71f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad097cc53e956f4352b33f0d2adaab71f">&#9670;&#160;</a></span>cell_end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Hash  = WyHash&lt;T&gt;, typename Eq  = std::equal_to&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cell_iterator <a class="el" href="classcplib_1_1HashTable.html">cplib::HashTable</a>&lt; T, Hash, Eq &gt;::cell_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns pointer to the end of the cell array. </p>
<p>This IS safe to dereference and always points to a sentinel cell. Iterator adaptors that skip unoccupied cells can check for the sentinel cell instead of storing and comparing with the end iterator. </p>

</div>
</div>
<a id="a8527692f870c42154f93387ad45bd6d6" name="a8527692f870c42154f93387ad45bd6d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8527692f870c42154f93387ad45bd6d6">&#9670;&#160;</a></span>find_cell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Hash  = WyHash&lt;T&gt;, typename Eq  = std::equal_to&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;bool Revive = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cell_iterator <a class="el" href="classcplib_1_1HashTable.html">cplib::HashTable</a>&lt; T, Hash, Eq &gt;::find_cell </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find an element that compares equal to the given value, or an empty cell if not found. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Revive</td><td>If <code>true</code>, may instead return a "phantom" (marked for deletion) cell when the value is not found. Used by <a class="el" href="classcplib_1_1HashTable.html#a7c3e3d62552ddcde47bde68a9b4641e5" title="Insert an element if there is no element already present that compares equal to it.">HashTable::insert</a> to reuse "phantom" cells and reduce rehashing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7c3e3d62552ddcde47bde68a9b4641e5" name="a7c3e3d62552ddcde47bde68a9b4641e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c3e3d62552ddcde47bde68a9b4641e5">&#9670;&#160;</a></span>insert() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Hash  = WyHash&lt;T&gt;, typename Eq  = std::equal_to&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;bool Replace = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcplib_1_1HashTable.html">cplib::HashTable</a>&lt; T, Hash, Eq &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert an element if there is no element already present that compares equal to it. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Replace</td><td>When an element that compares equal to <code>x</code> is found, will replace it if <code>true</code>, and will do nothing if <code>false</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a04c7ad4184bc1117f6f616133aa6dce9" name="a04c7ad4184bc1117f6f616133aa6dce9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04c7ad4184bc1117f6f616133aa6dce9">&#9670;&#160;</a></span>insert() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Hash  = WyHash&lt;T&gt;, typename Eq  = std::equal_to&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;bool Replace = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcplib_1_1HashTable.html">cplib::HashTable</a>&lt; T, Hash, Eq &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert an element if there is no element already present that compares equal to it.   </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Replace</td><td>When an element that compares equal to <code>x</code> is found, will replace it if <code>true</code>, and will do nothing if <code>false</code>.   </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac4915ac2418f2853af89b09e44a9f194" name="ac4915ac2418f2853af89b09e44a9f194"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4915ac2418f2853af89b09e44a9f194">&#9670;&#160;</a></span>rehash()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Hash  = WyHash&lt;T&gt;, typename Eq  = std::equal_to&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcplib_1_1HashTable.html">cplib::HashTable</a>&lt; T, Hash, Eq &gt;::rehash </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>new_cap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate the given capacity, and rehash all elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_cap</td><td>The new capacity. Must be a power of two and at least 4. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac6781bf89748842f602588c1aac677b4" name="ac6781bf89748842f602588c1aac677b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6781bf89748842f602588c1aac677b4">&#9670;&#160;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Hash  = WyHash&lt;T&gt;, typename Eq  = std::equal_to&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcplib_1_1HashTable.html">cplib::HashTable</a>&lt; T, Hash, Eq &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>new_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reserve capacity and temporary disable shrinking. </p>
<p>If current capacity can hold at least <code>new_size</code> non-empty cells, does nothing. Note that if there are already some deleted cells, which are also considered non-empty, the hash table may not be able to hold <code>new_size</code> elements without rehashing.</p>
<p>Otherwise, rehashes and allocates enough capacity for holding at least <code>new_size</code> non-empty cells, After this, the capacity will never "naturally" shrink (due to low load factor), unless it has "naturally" grown (due to high load factor) at least once.</p>
<p>Note that the cost of traversing the hash table is proportional to its capacity, not its size. Thus traversal should be avoided after calling this function until all desired elements are inserted. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/cplib/hash/<a class="el" href="table_8hpp_source.html">table.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>cplib</b></li><li class="navelem"><a class="el" href="classcplib_1_1HashTable.html">HashTable</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
